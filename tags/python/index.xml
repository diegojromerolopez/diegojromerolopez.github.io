<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>python on Diego J.'s Software Tar Pit</title><link>https://diegojromerolopez.github.io/tags/python/</link><description>Recent content in python on Diego J.'s Software Tar Pit</description><generator>Hugo -- gohugo.io</generator><managingEditor>diegojromerolopez@gmail.com (Diego J. Romero-López)</managingEditor><webMaster>diegojromerolopez@gmail.com (Diego J. Romero-López)</webMaster><lastBuildDate>Fri, 14 Feb 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://diegojromerolopez.github.io/tags/python/index.xml" rel="self" type="application/rss+xml"/><item><title>Joining test coverage from several test directories</title><link>https://diegojromerolopez.github.io/blog/2025/02/joining-test-coverage-from-several-test-directories/</link><pubDate>Fri, 14 Feb 2025 00:00:00 +0000</pubDate><author>diegojromerolopez@gmail.com (Diego J. Romero-López)</author><guid>https://diegojromerolopez.github.io/blog/2025/02/joining-test-coverage-from-several-test-directories/</guid><description>Joining test coverage from several test directories This post show a simple way of computing the coverage.py&amp;rsquo;s test coverage from different tests folders.
Introduction I have been using coverage.py since I started working with python, and while it works pretty well, let us say that the interface of the command line tool could be better.
I struggled for some minutes trying to filter out other folder I have in my tests folder that were not meant to have their test coverage computed.</description></item><item><title>Patching on setUp in Python's unittest</title><link>https://diegojromerolopez.github.io/blog/2025/02/patching-on-setup-in-pythons-unittest/</link><pubDate>Thu, 13 Feb 2025 00:00:00 +0000</pubDate><author>diegojromerolopez@gmail.com (Diego J. Romero-López)</author><guid>https://diegojromerolopez.github.io/blog/2025/02/patching-on-setup-in-pythons-unittest/</guid><description>Patching on setUp in Python&amp;rsquo;s unittest One of my favorite programming languages is Python, and I think that tests should be a foundational part of software development, so it is not strange that I delve a lot in Python&amp;rsquo;s unittest.
In this post we are going to show how to use unittest.mock.patch not in a decorator (the usual case) but in the setUp method.
Why should you care about this? Well, I have not cared about this after more than a decade of working with python (intermittently), because I was just used to the patch decorator.</description></item><item><title>EyesOnly</title><link>https://diegojromerolopez.github.io/blog/2022/11/eyesonly/</link><pubDate>Sat, 05 Nov 2022 00:00:00 +0000</pubDate><author>diegojromerolopez@gmail.com (Diego J. Romero-López)</author><guid>https://diegojromerolopez.github.io/blog/2022/11/eyesonly/</guid><description>Secrets are usually involuntary leaked by developers. Sometimes they are sent to external services like or written in a log by accident. Would not be useful to have a tool to limit the access to secrets? Enter EyesOnly.
EyesOnly: a package to limit access to secrets Dealing last years with containerazing applications has left me thinking in how we are passing some secrets as environment variables to the container. This is standard practice by the Cloud Native practitioners.</description></item><item><title>Immutability</title><link>https://diegojromerolopez.github.io/blog/2021/06/immutability/</link><pubDate>Sun, 06 Jun 2021 00:00:00 +0000</pubDate><author>diegojromerolopez@gmail.com (Diego J. Romero-López)</author><guid>https://diegojromerolopez.github.io/blog/2021/06/immutability/</guid><description>Introduction In this post I will explain the rationale about working with immutable objects and will present a personal project I&amp;rsquo;ve been working on the last few days: Gelidum.
La nevada by Francisco de Goya
Why immutability? Nowadays, most processors have some kind of parallelism or concurrency embedded in themselves. Single-flow-execution software is limited by the lowest speed unit in the system. There are some solutions that try to hide the wait for these slow sub-systems by computing in other execution-flows (threads or processes).</description></item><item><title>Concurrency and third party libraries</title><link>https://diegojromerolopez.github.io/blog/2015/08/concurrency-and-third-party-libraries/</link><pubDate>Sat, 01 Aug 2015 00:00:00 +0000</pubDate><author>diegojromerolopez@gmail.com (Diego J. Romero-López)</author><guid>https://diegojromerolopez.github.io/blog/2015/08/concurrency-and-third-party-libraries/</guid><description>Last Friday, one of my mates had a strange error in his code: incoherent an unrepeatable results arise en each execution.
His code (Python) was concurrent code and each thread used several libraries (BeautifulSoup41 was one of them) which they were not thread-safe. What does it mean? It means we cannot assure that atomicity is achieved in some operations executed by the threads, effectively sharing some data that must not be shared.</description></item></channel></rss>