<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>llm on Diego J.'s Software Tar Pit</title><link>https://diegojromerolopez.github.io/tags/llm/</link><description>Recent content in llm on Diego J.'s Software Tar Pit</description><generator>Hugo -- gohugo.io</generator><managingEditor>diegojromerolopez@gmail.com (Diego J. Romero-López)</managingEditor><webMaster>diegojromerolopez@gmail.com (Diego J. Romero-López)</webMaster><lastBuildDate>Mon, 12 Jan 2026 00:00:00 +0000</lastBuildDate><atom:link href="https://diegojromerolopez.github.io/tags/llm/index.xml" rel="self" type="application/rss+xml"/><item><title>How to use a LLM to upgrade your project</title><link>https://diegojromerolopez.github.io/blog/2026/01/how-to-use-a-llm-to-upgrade-your-project/</link><pubDate>Mon, 12 Jan 2026 00:00:00 +0000</pubDate><author>diegojromerolopez@gmail.com (Diego J. Romero-López)</author><guid>https://diegojromerolopez.github.io/blog/2026/01/how-to-use-a-llm-to-upgrade-your-project/</guid><description>How to use a LLM to upgrade your project In this post we pick up a Python 2.0 project and show how to use a LLM to upgrade a software project.
Introduction I will upgrade the Djanban project as it should be done. Not only making it work with the latest versions of the software packages, but improving its quality and making sure there are guardrails that make impossible for the developers</description></item><item><title>How NOT to use a LLM to upgrade your project</title><link>https://diegojromerolopez.github.io/blog/2026/01/how-not-to-use-a-llm-to-upgrade-your-project/</link><pubDate>Sun, 11 Jan 2026 00:00:00 +0000</pubDate><author>diegojromerolopez@gmail.com (Diego J. Romero-López)</author><guid>https://diegojromerolopez.github.io/blog/2026/01/how-not-to-use-a-llm-to-upgrade-your-project/</guid><description>How NOT to use a LLM to upgrade your project In this post we pick up a Python 2 project and show how NOT to use a LLM to upgrade an outdated software project.
This is a two-series go to the next post if you are only interested in how to do it correctly.
Introduction We tend to only focus on positive outcomes, following active (positive) advice, etc. But what about negative one?</description></item><item><title>Using LLMs to create a python library</title><link>https://diegojromerolopez.github.io/blog/2025/12/using-llms-to-create-a-python-library/</link><pubDate>Fri, 05 Dec 2025 00:00:00 +0000</pubDate><author>diegojromerolopez@gmail.com (Diego J. Romero-López)</author><guid>https://diegojromerolopez.github.io/blog/2025/12/using-llms-to-create-a-python-library/</guid><description>Using LLMs to create a python library I have used Gemini and Claude LLM models to create a mypy plugin to mark a function as pure: mypy-pure.
Introduction I think that static analysis in Python is a great opportunity to catch a lot of issues before running the program.
I do not even remember when, but I saw a thread in the Python official forum where a user was suggesting this @pure decorator idea to the Steering Council of Python.</description></item><item><title>Use LLMs to handle tedious tasks</title><link>https://diegojromerolopez.github.io/blog/2025/11/use-llms-to-handle-tedious-tasks/</link><pubDate>Mon, 24 Nov 2025 00:00:00 +0000</pubDate><author>diegojromerolopez@gmail.com (Diego J. Romero-López)</author><guid>https://diegojromerolopez.github.io/blog/2025/11/use-llms-to-handle-tedious-tasks/</guid><description>Use LLMs to handle tedious tasks There are some times where there are tedious tasks that need to be done in our software projects. We know how to do it but usually delay them because they are boring, not challenging and painfully long. The LLMs (Large Language Models) promise faster and better software development. Could we use a LLM to do them? Could we leverage the LLMs to free them from these chores?</description></item><item><title>The case for LLMs: faster development</title><link>https://diegojromerolopez.github.io/blog/2025/06/the-case-for-llms-faster-development/</link><pubDate>Sun, 29 Jun 2025 00:00:00 +0000</pubDate><author>diegojromerolopez@gmail.com (Diego J. Romero-López)</author><guid>https://diegojromerolopez.github.io/blog/2025/06/the-case-for-llms-faster-development/</guid><description>The case for LLMs: faster development Introduction Artificial Intelligence is all over the place in software development these days. From the first AI services that could generate images, to the code generation tools like GitHub Copilot, ChatGPT, Google Gemini, etc.
I wrote in other post that LLMs are not going to replace software engineers, but they are going to empower them in a lot of cases.
This post is a war story of mine, where I used a LLM service to create a new command for a CLI command tool written in a compiled language that I do not master.</description></item><item><title>Can LLMs replace engineers?</title><link>https://diegojromerolopez.github.io/blog/2025/05/can-llms-replace-engineers/</link><pubDate>Sat, 17 May 2025 00:00:00 +0000</pubDate><author>diegojromerolopez@gmail.com (Diego J. Romero-López)</author><guid>https://diegojromerolopez.github.io/blog/2025/05/can-llms-replace-engineers/</guid><description>Can LLMs replace engineers? This post provides my opinion about how a LLMs cannot replace a senior software engineer, even if the CEOs and other executives believe that it is possible.
Introduction I have been using Artificial Intelligence (in the form of LLMs) for several years already. My experience working with LLMs is limited to working with ChatGPT, Cursor and GitHub Copilot as of May 2025 (when this post was written).</description></item></channel></rss>