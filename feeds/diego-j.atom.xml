<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Diego J's on Software Engineering Research</title><link href="/" rel="alternate"></link><link href="/feeds/diego-j.atom.xml" rel="self"></link><id>/</id><updated>2015-08-20T00:30:00+02:00</updated><entry><title>Peopleware (or what they don't told you in college)</title><link href="/posts/2015/08/peopleware/" rel="alternate"></link><updated>2015-08-20T00:30:00+02:00</updated><author><name>Diego J.</name></author><id>tag:,2015-08-20:posts/2015/08/peopleware/</id><summary type="html">&lt;p&gt;I've just finished reading &lt;a href="https://en.wikipedia.org/wiki/Peopleware:_Productive_Projects_and_Teams"&gt;Tom De Marco &amp;amp; Timothy Lister's Peopleware&lt;/a&gt; and I feel like
this book should be recommended to all new Software Engineer graduates. Let me put some
light in this matter.&lt;/p&gt;
&lt;p&gt;I've been working for 8 years in a startup and none of my formal education in the University
prepared me for what I was going to experiment. Software Engineering is a social discipline
(we work in teams) but in my Computer Engineering degree&lt;sup id="fnref:1"&gt;&lt;a class="footnote-ref" href="#fn:1" rel="footnote"&gt;1&lt;/a&gt;&lt;/sup&gt; there are no management or organization courses.
So, when you scape the Engineering school you know how to make code but you don't know
really know how to work with another humans and of course know nothing about the perks of
the job. To sum up, &lt;strong&gt;you have no clue about the social component of the job&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;This book is old (1987 in its first edition) but what De Marco &amp;amp; Lister tell us is
timeless. First they introduce the nature of the job of the programmer and what should
be. Later they show the problems of the environment: noise, cubicle floorplans,
the loss of "the flow" etc.
The book ends with more teaching about human resources and productivity.&lt;/p&gt;
&lt;p&gt;It is truly a great book but you should &lt;strong&gt;not&lt;/strong&gt; read from cover to end. The book is organized
in little stories that help you understand the issue that the authors are dealing with.
&lt;strong&gt;It is a nightstand book&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Written in a non-formal way, this book is almost too funny to be considered a "job" book.
Thus, the authors show some kind of comments about other cultures and nations that readers
should not take very seriously to not be offended (Spanish Theory of Management&lt;sup id="fnref:2"&gt;&lt;a class="footnote-ref" href="#fn:2" rel="footnote"&gt;2&lt;/a&gt;&lt;/sup&gt;,
Uganda being "poor" and Australia being always on strike).
This comments seems very unprofessional to me.&lt;/p&gt;
&lt;p&gt;There are some other aspects I didn't like:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Not defining the Parkinsons' Law&lt;sup id="fnref:3"&gt;&lt;a class="footnote-ref" href="#fn:3" rel="footnote"&gt;3&lt;/a&gt;&lt;/sup&gt;, at least in a footnote.&lt;/li&gt;
&lt;li&gt;The use of the term "Corporate Entropy" given that in Physics, Entropy can be viewed as a
measure of chaos and the authors uses it to measure non-originality (sameness) in the employees.&lt;/li&gt;
&lt;li&gt;Not making a difference between programmers and software engineers.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Overall, it's a good book that I recommend to every programmer or software engineer that
is going to start working in his/her first job. &lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;Sadly when I studied there was no Software Engineering degree, only Computer Engineering.&amp;#160;&lt;a class="footnote-backref" href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:2"&gt;
&lt;p&gt;Authors claim that Spaniards thought that the economy could only be improved by the extraction of natural resources while the English thought that resources could be created. They tell that Spaniards where "Indians exploiters" while &lt;strong&gt;omit the barbaric treatment of natives by the English&lt;/strong&gt; (and later by the Americans). Sad sign of the authors being manipulated by the &lt;a href="https://en.wikipedia.org/wiki/Black_Legend"&gt;Black Legend&lt;/a&gt; or simply being manipulative.&amp;#160;&lt;a class="footnote-backref" href="#fnref:2" rev="footnote" title="Jump back to footnote 2 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:3"&gt;
&lt;p&gt;It is not really a law, it was a funny adage created by the British civil servant C. Northcote Parkinson: &lt;em&gt;work expands so as to fill the time available for its completion&lt;/em&gt;.&amp;#160;&lt;a class="footnote-backref" href="#fnref:3" rev="footnote" title="Jump back to footnote 3 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</summary><category term="software engineering"></category><category term="management"></category><category term="soft skills"></category><category term="book"></category></entry><entry><title>Progress Towards an Engineering Discipline of Software by Mary Shaw</title><link href="/posts/2015/08/progress-towards-an-engineering-discipline-of-software/" rel="alternate"></link><updated>2015-08-14T20:30:00+02:00</updated><author><name>Diego J.</name></author><id>tag:,2015-08-14:posts/2015/08/progress-towards-an-engineering-discipline-of-software/</id><summary type="html">&lt;p&gt;Several days ago, I watched this videotalk of Mary Shaw that tried to give an answer to the question
is Software Engineering an Engineering discipline yet?&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.youtube.com/watch?v=S03bsjs2YnQ"&gt;&lt;img alt="SATURN 2015 Keynote: Progress Towards an Engineering Discipline of Software by Mary Shaw" src="http://img.youtube.com/vi/S03bsjs2YnQ/0.jpg" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Dr. Shaw makes a parallelism with Civil Engineering that started as a &lt;strong&gt;empirical discipline&lt;/strong&gt;
and, thanks to strong scientific foundations, evolved to what we could call &lt;em&gt;full&lt;/em&gt; engineering.&lt;/p&gt;
&lt;p&gt;Software Engineering is not there yet. It needs more work and professionalization. 
&lt;strong&gt;Many of the so-called Software Engineers have no software engineering knowledge and/or skills&lt;/strong&gt;
and therefore software catastrofes happens. She even gives some examples of software failures
like the &lt;a href="http://www.safetyresearch.net/blog/articles/toyota-unintended-acceleration-and-big-bowl-%E2%80%9Cspaghetti%E2%80%9D-code"&gt;Toyota unintended acceleration affaire&lt;/a&gt;,
and the multiple identity thefts in our connected world.&lt;/p&gt;
&lt;p&gt;At the end of the talk, she makes a good summary of the last years of advancements in
Software Engineering and also drafts what it could be the future of our young discipline.&lt;/p&gt;
&lt;p&gt;One hundred percent I recommend watching this videotalk to every Software Engineer.&lt;/p&gt;</summary><category term="software engineering"></category><category term="engineering"></category><category term="talk"></category><category term="videotalk"></category></entry><entry><title>Concurrency and Third Party Libraries</title><link href="/posts/2015/08/concurrency-and-third-party-libraries/" rel="alternate"></link><updated>2015-08-01T19:00:00+02:00</updated><author><name>Diego J.</name></author><id>tag:,2015-08-01:posts/2015/08/concurrency-and-third-party-libraries/</id><summary type="html">&lt;p&gt;Last friday, one of my mates had a strange error in his code: incoherent an irrepetible results arise en each execution.&lt;/p&gt;
&lt;p&gt;His code (Python) was concurrent code and each thread used several libraries (&lt;a href="http://www.crummy.com/software/BeautifulSoup/bs4/doc/"&gt;BeautifulSoup4&lt;/a&gt;&lt;sup id="fnref:1"&gt;&lt;a class="footnote-ref" href="#fn:1" rel="footnote"&gt;1&lt;/a&gt;&lt;/sup&gt; was one of them) which they were &lt;strong&gt;not&lt;/strong&gt; thread-safe. What does it mean? It means we cannot assure that atomicity is achieved in some operations executed by the threads, effectively sharing some data that must not be shared.&lt;/p&gt;
&lt;p&gt;I ended up helping him to set a critical section in these not-thread-safe parts of his code but this situation kept me wondering why a library that parses XML is not thread-safe and what kind of common resources used of the system. I couldn’t spend more time investigating this issue but this kept me wondering if this “feature” is not a case of bad software design.&lt;/p&gt;
&lt;p&gt;Take a look if everything you are using is thread-safe before you start partitioning your execution flow in threads.&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;Technically, BeautifulSoup4 is a wrapper, not a library. Developer can choose several parsers available (html5lib, lxml…) when using it in an application. &lt;a href="https://github.com/html5lib/html5lib-python"&gt;Html5lib&lt;/a&gt; library is what we were using at the time.&amp;#160;&lt;a class="footnote-backref" href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</summary><category term="concurrency"></category><category term="software engineering"></category><category term="programming"></category></entry><entry><title>Managing clients</title><link href="/posts/2015/07/managing-clients/" rel="alternate"></link><updated>2015-07-27T23:00:00+02:00</updated><author><name>Diego J.</name></author><id>tag:,2015-07-27:posts/2015/07/managing-clients/</id><summary type="html">&lt;h1&gt;The Players&lt;/h1&gt;
&lt;p&gt;It's not a secret that software engineers prefer a clean and completed specification than metting with clients.&lt;/p&gt;
&lt;p&gt;We tend to think that meetings are a waste of time and many of our colleagues are not very fond of what is called &lt;a href="https://en.wikipedia.org/wiki/Soft_skills"&gt;soft skills&lt;/a&gt;. &lt;/p&gt;
&lt;p&gt;On the other side, we have some clients that have no idea about software and want the changes in their platform now.&lt;/p&gt;
&lt;p&gt;What is all of that? Let me tell you, a recipe for the disaster. &lt;/p&gt;
&lt;h1&gt;The Setting&lt;/h1&gt;
&lt;p&gt;In a startup, we are very close to our clients, so we engineers manage directly the relationship with them.&lt;/p&gt;
&lt;p&gt;Let's add some extra complexity. The project you have assigned to has no documentation and has a high &lt;a href="https://en.wikipedia.org/wiki/Technical_debt"&gt;technical debt&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The client is not cooperating and is impatient...&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;What do you do?&lt;/strong&gt;&lt;/p&gt;
&lt;h1&gt;The Solution&lt;/h1&gt;
&lt;h2&gt;Technical solution&lt;/h2&gt;
&lt;p&gt;The technical debt problem needs to be resolved, how? Analyzing the current system: what does (software requirements) and how does it (software design).&lt;/p&gt;
&lt;h2&gt;Cliente managing&lt;/h2&gt;
&lt;p&gt;The client feels lied by its older outsourcing company, he/she needs a special treatment. How can we give him/her that?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;How can we make our client feel safe with working with us?&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;We have to guide our clients&lt;/h3&gt;
&lt;p&gt;One of the most successful aspects of Agile development is the change of developers-cliente relationship.&lt;/p&gt;
&lt;p&gt;We must be the calendar, reminder and notifier of the client. We define when we are going to end our sprints and deliver the software modules to be validated by our client.&lt;/p&gt;
&lt;h3&gt;Clients are limited&lt;/h3&gt;
&lt;p&gt;Don't suppose any knowledge.&lt;/p&gt;
&lt;p&gt;The client can be wise in his/her field (many times it is not) but doesn't know anything about software.&lt;/p&gt;
&lt;p&gt;We should talk in a simple vocabulary, explaining the concepts, making metaphors and real like comparisons to achieve his/her complete understanding.&lt;/p&gt;
&lt;h3&gt;Clients have needs but ask for changes&lt;/h3&gt;
&lt;p&gt;Clients have background needs because of business or personal requirements but they express them in form of "changes" in the software, even telling us how to do the changes.&lt;/p&gt;
&lt;p&gt;We should know these base needs instead of the particular changes, because most of the time, things can be done easily or better.&lt;/p&gt;
&lt;h3&gt;Don't lose control&lt;/h3&gt;
&lt;p&gt;Clients can be disrespectful, condescending or can be tyrannical. &lt;/p&gt;
&lt;p&gt;We are engineers, we must be assertive, defend our integrity as humans but we must &lt;em&gt;not&lt;/em&gt; attack the client.&lt;/p&gt;
&lt;p&gt;Technology makes people feel vulnerable, specially illiterate people, so they tend to show this feeling as anger or other unpleasant emotions.&lt;/p&gt;
&lt;h1&gt;Conclusion&lt;/h1&gt;
&lt;p&gt;We don't work &lt;em&gt;for&lt;/em&gt; a client, we work &lt;em&gt;with&lt;/em&gt; a client.&lt;/p&gt;
&lt;p&gt;Many times a conversation can avoid developing new features that won't be used or the cancelation of the project.&lt;/p&gt;
&lt;p&gt;Soft skills are important, yes, even for an engineer. You will have mettings with clients, so practice your "human" abilities.&lt;/p&gt;</summary><category term="clients"></category><category term="software engineering"></category><category term="people"></category><category term="project management"></category></entry><entry><title>Real Software Architecture</title><link href="/posts/2015/03/real-software-architecture/" rel="alternate"></link><updated>2015-03-03T21:53:00+01:00</updated><author><name>Diego J.</name></author><id>tag:,2015-03-03:posts/2015/03/real-software-architecture/</id><summary type="html">&lt;p&gt;Simon Brown is an independent software consultant from Jersey (UK) and gave this talk
about Software Architecture in GOTO Amsterdam 2014.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.youtube.com/watch?v=GAFZcYlO5S0"&gt;&lt;img alt="Software Architecture vs. Code GOTO 2014 talk" src="http://img.youtube.com/vi/GAFZcYlO5S0/0.jpg" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;This talk delights me in several ways. First, Simon show us several common problems that happens in
many software companies: diagrams of the software are not synchronized with code because.
That is, we design some type of software architecture but we don't follow our own path when
coding.&lt;/p&gt;
&lt;p&gt;He thinks (me too) that software diagram current methodologies are difficult and
not &lt;em&gt;pleasant&lt;/em&gt; (I would say) to use. We continue to theorize about perfect software
designs but when we make the code we simply don't take them in consideration.&lt;/p&gt;
&lt;p&gt;This way, he shows a software architecture model that enfatizes the communication inside
the team and with stakeholders. Thus, the most important thing is that these diagrams
can be the &lt;em&gt;actual plan&lt;/em&gt; of the code of the project and with his guidelines we can have no
discrepancies between software architecture and code organization and structure. &lt;/p&gt;
&lt;p&gt;Simon has published a very &lt;a href="https://leanpub.com/software-architecture-for-developers/"&gt;interesting book&lt;/a&gt; I plan to read.
I'll update this post in the future when I read it.&lt;/p&gt;
&lt;p&gt;Go, watch the video and think about this problem.&lt;/p&gt;</summary><category term="talk"></category><category term="software engineering"></category><category term="videotalk"></category><category term="software architecture"></category></entry><entry><title>Back to basics, the mythical man-month</title><link href="/posts/2014/11/back-to-basics-the-mythical-man-month/" rel="alternate"></link><updated>2014-11-04T21:00:00+01:00</updated><author><name>Diego J.</name></author><id>tag:,2014-11-04:posts/2014/11/back-to-basics-the-mythical-man-month/</id><summary type="html">&lt;p&gt;&lt;a href="https://en.wikipedia.org/wiki/Fred_Brooks"&gt;Frederick P. Brooks&lt;/a&gt; is what I'd call a true pioneer.&lt;/p&gt;
&lt;p&gt;Without any existing knowledge and only his own experience in the "tar pit" (as himself call this software development world), he distilled some universal truths of the Software Engineering world. So, the Mythical Man-Month is a summary of his ideas.&lt;/p&gt;
&lt;p&gt;This book is a night stand book, that is, you cannot hope to end it in a few days. You have to read slowly, thinking as a 60s software developer, with their limited tools and machines to fully understand this book.&lt;/p&gt;
&lt;p&gt;Its content can be seen as obvious, but is interesting seeing the thought process that made the bases of what we call now Software Engineering. Things like how to plan a software project, team specialization, the use of high languages over efficiency, a strict and well-done documentation, etc. are described with some detail in the book with real world examples of Brooks or men of his time.&lt;/p&gt;
&lt;p&gt;Of course many readers stop reading after ending chapter 2 where the author explains that software projects are different compared to other projects because you cannot increase development speed introducing more members to the developing team. You'll need to teach them the project internals, increasing the overall time cost of the project. But I think every chapter has its teaching.&lt;/p&gt;
&lt;p&gt;For example, in chapter 3, "The surgical team", Brooks compares a surgical team where every member has a specialized tasks to his idea of software developing team. Nowadays it is very common to see many jobs for "full-stack developers", what in my opinion is completely mistaken. You cannot expect to be fully competent in dozens of disciplines (and technologies).&lt;/p&gt;
&lt;p&gt;Other interesting chapter for me is "The documentary hypothesis" where Brooks defends the idea of having formal documents for each project like objetives, specifications, schedule, etc. In the agile startup world this is simply wasted time, the old idea of "only the code is what is important" has returned very strong this days because of the culture of skyrocketing your career and rockstar programmer. This two ideas are a bit naïve and against the software engineering principles of software quality and maintainability.&lt;/p&gt;
&lt;p&gt;The last thing I want to note about this book is that Brooks even defines the two careers in the software world: programmers and management. Where many people see both of them as oposite careers, Brooks sees them as complementary positions of the organization but encouraging employees to stay in "the technical ladder" by paying them more. Yes, take a look to chapter "Plan the organization for a change".&lt;/p&gt;
&lt;p&gt;To conclude this post, Brooks' book is a window to the past that teach us many principles of Software Engineering with real examples. I recommend its lecture to every undergraduate student of Computer Science or Software Engineering degrees. Many of the problems of nowadays software developing organizations can be seen in this book pages. I encourage every software developer or software engineer to read this book and learn the basic principles of Software Engineering.&lt;/p&gt;</summary><category term="books"></category><category term="software engineering"></category><category term="startup"></category></entry><entry><title>Welcome</title><link href="/posts/2014/10/welcome/" rel="alternate"></link><updated>2014-10-01T21:00:00+02:00</updated><author><name>Diego J.</name></author><id>tag:,2014-10-01:posts/2014/10/welcome/</id><summary type="html">&lt;p&gt;For anyone not knowing me, I’m a software engineer working in a startup in south Spain.&lt;/p&gt;
&lt;p&gt;In 2014 I ended my Software Engineering Research Masters Program and not satisfied with what I’ve learned, I’m going to continue my research in this field.&lt;/p&gt;
&lt;p&gt;This blog is going to be my notebook in this amazing trip.&lt;/p&gt;
&lt;p&gt;Please, note that this blogs only reflect my personal opinions and views, it does &lt;em&gt;not&lt;/em&gt; reflect the views of my past, present or future employers.&lt;/p&gt;</summary><category term="welcome"></category><category term="test"></category></entry></feed>