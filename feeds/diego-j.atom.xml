<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Diego J's on Software Engineering Research</title><link href="http://diegojromerolopez.github.io/" rel="alternate"></link><link href="http://diegojromerolopez.github.io/feeds/diego-j.atom.xml" rel="self"></link><id>http://diegojromerolopez.github.io/</id><updated>2016-03-05T19:40:00+01:00</updated><entry><title>Refactoring</title><link href="http://diegojromerolopez.github.io/posts/2016/03/refactoring/" rel="alternate"></link><updated>2016-03-05T19:40:00+01:00</updated><author><name>Diego J.</name></author><id>tag:diegojromerolopez.github.io,2016-03-05:posts/2016/03/refactoring/</id><summary type="html">&lt;h1&gt;Introduction&lt;/h1&gt;
&lt;p&gt;Software is not a static element in a business. It evolves as business needs evolve. How can we make changes in software and keep high quality or even better don't decrease it as we develop functionality?&lt;/p&gt;
&lt;h1&gt;Refactoring&lt;/h1&gt;
&lt;p&gt;&lt;a href="http://refactoring.com/"&gt;Refactoring&lt;/a&gt; &lt;strong&gt;is the process of changing code structure for the better while keeping the same functionality&lt;/strong&gt;. It should be a continuos activity made during software development, with the aim of easing maintainability of software.&lt;/p&gt;
&lt;p&gt;The main aim of refactoring is having a simpler software design, increasing its understandability and therefore, making easier software maintenance and extension.&lt;/p&gt;
&lt;h1&gt;How can I learn refactoring?&lt;/h1&gt;
&lt;p&gt;Martin Fowler&lt;sup id="fnref:1"&gt;&lt;a class="footnote-ref" href="#fn:1" rel="footnote"&gt;1&lt;/a&gt;&lt;/sup&gt; wrote a compendium of known refactorings: &lt;a href="http://martinfowler.com/books/refactoring.html"&gt;Refactoring&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;The heuristics used to know when to apply a refactoring pattern is what he calls "smells of software". If the software &lt;em&gt;stinks&lt;/em&gt;, you have to refactor it. Or in a more formal way, software smell is only the first common symptoms of fracture in the design of a piece of software.&lt;/p&gt;
&lt;p&gt;In the same way a neighborhood starts decaying and its first symptoms are broken windows, garbage in the street, graffitis in the walls, etc. Software must be taken care when we detect bad quality code.&lt;/p&gt;
&lt;p&gt;Thus, I really like the way Martin explains each pattern. Each one of them has a name, motivation and application description process step by step. There is also some easy examples that help you understand what means applying the pattern to a piece of code.&lt;/p&gt;
&lt;h1&gt;How to refactor?&lt;/h1&gt;
&lt;p&gt;Changing code. Simply as that. Given we have a test that our bad quality passes, our aim has to be to apply the appropriate software refactoring pattern to make it pass too.&lt;/p&gt;
&lt;p&gt;Of course we can apply several of them in the process of refactoring, we don´t have to be robots. But one thing is for sure, our changed must be tested. Martin emphasizes the use of tests as a foundation of refactoring.&lt;/p&gt;
&lt;p&gt;Why use tests? The test is what we use to assert that the refactoring does not break our software. If we don't have test, how can we assure software keeps working?&lt;/p&gt;
&lt;h1&gt;Conclusion&lt;/h1&gt;
&lt;p&gt;Read Martin Fowler's book and then, read again and keep it as a reference manual.&lt;/p&gt;
&lt;p&gt;As the software projects moves forward, refactorings will be needed to fix missteps taken during software development.&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;Martin Fowler is one of the current giants of Software Engineering. He is a big defender of using microservice architectures and refactoring as tools to increase software quality. His &lt;a href="http://www.martinfowler.com/"&gt;site&lt;/a&gt; has many Software Engineering resources and is a must-go site from time to time for me.&amp;#160;&lt;a class="footnote-backref" href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</summary><category term="software engineering"></category><category term="refactoring"></category><category term="code"></category></entry><entry><title>Waterfall process model is harmful</title><link href="http://diegojromerolopez.github.io/posts/2016/02/waterfall-process-model-is-harmful/" rel="alternate"></link><updated>2016-02-20T20:30:00+01:00</updated><author><name>Diego J.</name></author><id>tag:diegojromerolopez.github.io,2016-02-20:posts/2016/02/waterfall-process-model-is-harmful/</id><summary type="html">&lt;h1&gt;Introduction&lt;/h1&gt;
&lt;p&gt;Waterfall model is a development process based on doing software development processes one after another and not looking back.&lt;/p&gt;
&lt;p&gt;Here is a simple diagram (&lt;a href="https://en.wikipedia.org/wiki/Waterfall_model#/media/File:Waterfall_model.svg"&gt;from Wikipedia&lt;/a&gt;) of that model:&lt;/p&gt;
&lt;p&gt;&lt;img alt="Waterfall model" src="/images/WaterfallModelFromWikipedia.png" /&gt;&lt;/p&gt;
&lt;p&gt;That is it supposes we are infalible and the client is infalible so each phase is perfect and serves well enough the next.&lt;/p&gt;
&lt;h1&gt;Issues with waterfall model&lt;/h1&gt;
&lt;p&gt;Waterfall process model suffered a total criticism by Winston W. Royce in his paper
&lt;a href="https://www.cs.umd.edu/class/spring2003/cmsc838p/Process/waterfall.pdf"&gt;Managing the development of large software systems&lt;/a&gt;,
published in the Proceedings of IEE WESCON in August 1970.&lt;/p&gt;
&lt;p&gt;In this paper, Royce clearly showed that he was fully against using this step-by-step process. Indeed, in the second page of this work
he said: &lt;em&gt;I believe in this concept, but the implementation described above is risky and invites failure.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Why he was so vehenmetly against the waterfall model? The rest of the paper gives some support to his claim being the most important these ones:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;If some error is detected in test phase, there can be needed changes in requirement phase.&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;The program design phase can create changes in software requirement phase.&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Already in 1970 there were voices that claimed waterfall model was not adequate for software engineering.&lt;/p&gt;
&lt;h1&gt;Solutions for this flawed model&lt;/h1&gt;
&lt;p&gt;In his paper, Royce defined what he called &lt;em&gt;an early simulation of the final product&lt;/em&gt;, where the process of developing early prototipos of software that
can affected each one of the phases of the model. So, what we call iterations or early releases to the client was almost defined in 1970! Not in the '90s
but 40 years before the agile manifesto.&lt;/p&gt;
&lt;p&gt;The relase often &lt;em&gt;adagio&lt;/em&gt; and the idea of releasing working software is also present in this paper: &lt;em&gt;They must quickly sense the trouble spots in the design, model them, model their alternatives, forget the straightforward aspects of the design which aren't worth studying at this early point, and finally arrive at an error-free program.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Royce, furthermore, advocate for involving the client during the software development process: 
&lt;em&gt;To give the contractor free rein between requirement definition and operation is inviting trouble.&lt;/em&gt;&lt;/p&gt;
&lt;h1&gt;Why he was forgotten?&lt;/h1&gt;
&lt;p&gt;Well, this paper is &lt;strong&gt;hard to read&lt;/strong&gt; because it has no clear aim. He is criticising a software development model but also advocating fo a new one that
is not very clear presented. His new model has some &lt;em&gt;agile features&lt;/em&gt; but also mixes some of his heuristic solutions to problems he has experimented. Maybe
too much detail in the description of his model is the cause people didn't put his teachings in practice. &lt;strong&gt;I had a hard time separating the basic principles from his particular model&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;To make things worse it has many figures that, if you don't fully read it, can give you a misleading idea of what Royce is showing here.&lt;/p&gt;
&lt;p&gt;In that time there were no software engineers, only programmers with different backgrounds. I can assume this paper
mislead many people into thinking that this model was enough for their non-critical software developments.&lt;/p&gt;
&lt;p&gt;Royce doesn't use the term "waterfall"&lt;sup id="fnref:1"&gt;&lt;a class="footnote-ref" href="#fn:1" rel="footnote"&gt;1&lt;/a&gt;&lt;/sup&gt; along the paper so maybe he was ahead of his time and was not understood.&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;"Waterfall" was coined in 1976 by Bell and Thayer.&amp;#160;&lt;a class="footnote-backref" href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</summary><category term="software engineering"></category></entry><entry><title>Project saboteurs</title><link href="http://diegojromerolopez.github.io/posts/2016/02/project-saboteurs/" rel="alternate"></link><updated>2016-02-13T20:00:00+01:00</updated><author><name>Diego J.</name></author><id>tag:diegojromerolopez.github.io,2016-02-13:posts/2016/02/project-saboteurs/</id><summary type="html">&lt;h1&gt;Introduction&lt;/h1&gt;
&lt;p&gt;You have just been appointed leader of a new fascinating project. Hard years working
in boring tasks have paid off.  You are excited before your big day: your first meeting
with your client (the owner of the business) and some other stakeholders (managers and
other employees of the business).&lt;/p&gt;
&lt;h1&gt;Sabotage&lt;/h1&gt;
&lt;p&gt;So the meeting starts. Relationship with the business owner is smooth and you
begin to write notes about software requirements, current system limitations,
technologies... You know that you'll have more than enough information to make
the first requirement document.&lt;/p&gt;
&lt;p&gt;Then, the saboteur begins to show a despising attitude questioning the very first
need of this new software for the business, doubting about your professionality
or even worse telling you what you have to do. Summing up, he/she has a
menacing, primitive, non-constructive critic and rude behavior during all the meeting.&lt;/p&gt;
&lt;p&gt;You want everybody in the team but are sweating trying to stop this kind of
sabotage your seeing.&lt;/p&gt;
&lt;p&gt;This individual sees you as an enemy and has made it clear in the meeting making
things harder for you. He/she will continue to make things harder during the project.&lt;/p&gt;
&lt;h1&gt;But why?&lt;/h1&gt;
&lt;p&gt;The reason this person is boycotting the meeting and hence, the project is that
&lt;strong&gt;the saboteur is scared&lt;/strong&gt;. Humans base their society on customs and tradition,
and when something "shakes" their ground, they rebel against it.&lt;/p&gt;
&lt;p&gt;You are a software engineer, you are more than capable of optimizing a business
you fully understand, making changes and how they have been working until now.
There are people that like this kind of change because they see it like progress.
There are others that will resist any kind of change above all.&lt;/p&gt;
&lt;h1&gt;Are you going to going to order how to do my job?&lt;/h1&gt;
&lt;p&gt;Other kind of saboteurs have too much ego and simply don't want to hear that
they can be wrong in the way they work.&lt;/p&gt;
&lt;p&gt;As I said earlier, our education and experience gives us the skill of analyzing
process flows pretty well and can optimize them, improving the business of our client.&lt;/p&gt;
&lt;p&gt;Nobody wants to lose the job and if you succeed in the project, they think they
can be fired.&lt;/p&gt;
&lt;h1&gt;Why are saboteurs employed?&lt;/h1&gt;
&lt;p&gt;But giving that they are toxic employees, how do saboteurs keep their jobs?&lt;/p&gt;
&lt;p&gt;On one hand, it could be because they are civil workers and they can't be fired.&lt;/p&gt;
&lt;p&gt;On the other hand, usually, nobody can make some tasks they do it very well, so
there is no suitable replacement for saboteurs. I'm afraid you will be surprised
the low level of problem solving and autonomy that most people have. If the
saboteur is marginally better than the rest, he/she will remain employed for a
long time.&lt;/p&gt;
&lt;h1&gt;What can be done about these project saboteurs?&lt;/h1&gt;
&lt;p&gt;They just need to feel that they are managing the situation and they
are "important" during project development. What means to be "important"? Asking
them about what are their needs and above all, every change proposed of their
"way of doing the things" must be "for the sake of their work" or "because it
helps them do some task".&lt;/p&gt;
&lt;p&gt;Many times they will use a tone not appropriate for a business like environment.
No problem, be more polite than ever, showing that you are here for help a business.
Saboteur will feel his/her intentions are being made clear and will cease his/her
attitude.&lt;/p&gt;
&lt;p&gt;An agile project management is the best solution for changing requirements. Thus
it shows everybody the costs of these requirement changes. So,
from third or fourth iteration they will think again before asking the owner to
spend more money in a non-vital feature. Probably owner will have a chat with them
and will ask them to change their attitude.&lt;/p&gt;
&lt;h1&gt;Conclusions&lt;/h1&gt;
&lt;p&gt;The best you can do is have the owner of the business on your side.&lt;/p&gt;
&lt;p&gt;Do not accept rude comments, insults or questioning your professionality from anybody.
Call off the meeting until everybody that sits bring something to help the development
of the project.&lt;/p&gt;
&lt;p&gt;Use an agile project management that shows them the cost of not behaving as a part
of the software project development team. Of course, pair this agile project with
a iterated bill system to make it more clear.&lt;/p&gt;</summary><category term="software engineering"></category><category term="clients"></category></entry><entry><title>Self-improvement</title><link href="http://diegojromerolopez.github.io/posts/2016/01/self-improvement/" rel="alternate"></link><updated>2016-01-30T20:30:00+01:00</updated><author><name>Diego J.</name></author><id>tag:diegojromerolopez.github.io,2016-01-30:posts/2016/01/self-improvement/</id><summary type="html">&lt;h1&gt;The rules of the game have changed&lt;/h1&gt;
&lt;p&gt;During many years, society expected you to graduate and find a job you kept until your retirement. Not many people changed jobs and only professions like medical doctors and lawyers keep studying and improving their skills.&lt;/p&gt;
&lt;p&gt;Now the rules of the game have changed and nobody expects that almost from any profession. Maybe you are a baker and expect to use the same ingredients and make the same bread over and over again, but your clients can change or acquire new tastes! Thus, what about improving the costs? Maybe a new machine could make the baking process cheaper and you should know about its existence…&lt;/p&gt;
&lt;h1&gt;So, what about software engineers?&lt;/h1&gt;
&lt;p&gt;Software-related professions are very young if you compare with medicine or legal ones. Not only technologies change, are born and disappear each year, techniques and even (some) Computational Foundations too.&lt;/p&gt;
&lt;p&gt;Yes, if you are a software engineer you should be improving yourself.&lt;/p&gt;
&lt;p&gt;If you don’t do it, you’ll be passed by your profession mates, you will lose interesting jobs and of course, you’ll end up being a mediocre &lt;em&gt;programmer&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Note that I’ve said &lt;em&gt;programmer&lt;/em&gt; and not software engineer&lt;sup id="fnref:1"&gt;&lt;a class="footnote-ref" href="#fn:1" rel="footnote"&gt;1&lt;/a&gt;&lt;/sup&gt;, that’s because if you don’t improve yourself, you are walking backwards. Our profession is like a race. If you are working the same way 10 years ago, you are stopped in the middle of the track while your competitors are running towards the finish line.&lt;/p&gt;
&lt;h1&gt;What should be my sources of study?&lt;/h1&gt;
&lt;p&gt;Everything, literally everything. From MOOCS, masters degree programes to books.&lt;/p&gt;
&lt;p&gt;MOOCS are a great tool to learn new technologies and I prefer them over books simply because I don’t like buying books with &lt;em&gt;expiration date&lt;/em&gt; as technologies tend to have. &lt;a href="https://www.coursera.org/"&gt;Coursera&lt;/a&gt; have many specializations, &lt;a href="https://www.udacity.com/"&gt;Udacity&lt;/a&gt; have what they call &lt;em&gt;nanodegrees&lt;/em&gt; and &lt;a href="https://www.edx.org/"&gt;edx&lt;/a&gt; have multiple courses of several topics. My last course was about Ocaml and was taught by &lt;a href="https://www.france-universite-numerique-mooc.fr/"&gt;France Université Numérique&lt;/a&gt;. Its quality was excellent and it helped me understand functional programming foundations thru Ocaml.&lt;/p&gt;
&lt;p&gt;Books fill the empty space that college education gave me. I try to read at least one each month although it is difficult given the length of software books. I prefer to buy my books in second-hand stores in &lt;a href="http://www.abebooks.co.uk/"&gt;abebooks&lt;/a&gt; but you can buy them in epub or Kindle format to read them in a eReader. Currently I’m reading &lt;a href="https://www.manning.com/books/soft-skills"&gt;Soft-Skills&lt;/a&gt; and &lt;a href="http://martinfowler.com/books/refactoring.html"&gt;Refactoring&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Of course there is also the option to earn a M.Sc./M.Eng. (or M.Res. in my case) in a reputable university. Assuming you have the money (or can ask anybody but a bank&lt;sup id="fnref:2"&gt;&lt;a class="footnote-ref" href="#fn:2" rel="footnote"&gt;2&lt;/a&gt;&lt;/sup&gt;), it is a good way to upgrade your qualifications and your career. Of course, don’t join a masters programe just for the degree, join it because you are passionate about the topic they teach.&lt;/p&gt;
&lt;h1&gt;Open source projects&lt;/h1&gt;
&lt;p&gt;It is said that every programer&lt;sup id="fnref:3"&gt;&lt;a class="footnote-ref" href="#fn:3" rel="footnote"&gt;3&lt;/a&gt;&lt;/sup&gt; should be programming in his or her spare time. I fully disagree with that idea, should a surgeon be making surgeries in his spare time? But, while I disagree, I agree that having open source projects is a great way of forming part of the community and, of course, the best way to show our skills.&lt;/p&gt;
&lt;p&gt;So, maybe the solution can be &lt;strong&gt;convince your manager to free some parts of company software&lt;/strong&gt; you wrote. Try to show him the positive effect that can have freeing some module and I’m sure that he will be delighted to achieve good PR to the company. Thus, remember him that this module will be improved with no cost for other developers, so it’s a win-win situation: good PR and &lt;em&gt;gratis&lt;/em&gt; software.&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;Please note that I don’t consider the terms programmer, software developer and software engineer equal. A &lt;strong&gt;programmer&lt;/strong&gt; is a person who writes code to solve a problem, usually he or she has no specific education and uses a programming language (and environment) as a tool. &lt;strong&gt;Software developers&lt;/strong&gt; are programmers that fully understand the stack where their code runs. &lt;strong&gt;Software Engineers&lt;/strong&gt; are software developers with knowledge of the foundations of software they write: algorithmic theory, heuristics, programming language theory, concurrent/parallel programming, security, software design, information theory, project/client management, etc.&amp;#160;&lt;a class="footnote-backref" href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:2"&gt;
&lt;p&gt;I don’t suggest you ask for a bank loan to study. Work for several years and when you have the money apply to join a master programe.&amp;#160;&lt;a class="footnote-backref" href="#fnref:2" rev="footnote" title="Jump back to footnote 2 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:3"&gt;
&lt;p&gt;Every software engineer is a programmer. Don’t be fooled by &lt;em&gt;software designers&lt;/em&gt; that create UML diagrams and pass them to programmers that code. Software engineers rely on programmers for many parts of the code, but they need to be lead by a software engineer that will code with them.&amp;#160;&lt;a class="footnote-backref" href="#fnref:3" rev="footnote" title="Jump back to footnote 3 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</summary><category term="software engineering"></category><category term="education"></category></entry><entry><title>Agile project management</title><link href="http://diegojromerolopez.github.io/posts/2016/01/agile-project-management/" rel="alternate"></link><updated>2016-01-10T20:00:00+01:00</updated><author><name>Diego J.</name></author><id>tag:diegojromerolopez.github.io,2016-01-10:posts/2016/01/agile-project-management/</id><summary type="html">&lt;h1&gt;Software Engineering is a special type of Engineering&lt;/h1&gt;
&lt;p&gt;During too much time Software Engineering has been molded as a traditional Engineering, with the same terms and ideas that came from this disciplines.
But they failed.&lt;/p&gt;
&lt;p&gt;Firstly, Software Engineering has an immaterial final product. It is not a bridge, a road, or a mine for example. Thus, software engineers works with
ideas more than anything else.&lt;/p&gt;
&lt;p&gt;Thus, traditional engineers are limited by Physics laws while software engineers are only limited by the computational model they use and by the power of the
machines their software run. Nowadays, for non-complex tasks (traditional business logic), these machines are more than enough.&lt;/p&gt;
&lt;p&gt;Therefore, this field should be an easy field where most projects can be easily estimated, developed and delivered without any problem. This could be true
if needs software satisfies did not change. Requirements change and software also can be changed, so why shouldn't we update client's software?&lt;/p&gt;
&lt;p&gt;Even if we could accept all the changes client requires, it could be worst. What about a client that doesn't know what he wants? And what about a client that
&lt;strong&gt;what he/she wants is not what he/she needs&lt;/strong&gt;?&lt;/p&gt;
&lt;p&gt;What happened because of this copycat mistake? Many software projects were failed, abandoned. The situation in many projects was fine until there was an
increasing feeling of dissatisfaction between client because his/her new issues could not be resolved. The end came when there were no trust between client an
developing team (client felt he/she was being lied).&lt;/p&gt;
&lt;h1&gt;What is agile?&lt;/h1&gt;
&lt;p&gt;The term Agile was coined in a meeting of some important figures of the industry. Their idea was to make a common ground to several practices each one
of them were using. So at the end, they came with a "creed" called &lt;a href="http://agilemanifesto.org/"&gt;Software Manifesto&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;We are uncovering better ways of developing
software by doing it and helping others do it.
Through this work we have come to value:&lt;/p&gt;
&lt;p&gt;Individuals and interactions over processes and tools
Working software over comprehensive documentation
Customer collaboration over contract negotiation
Responding to change over following a plan&lt;/p&gt;
&lt;p&gt;That is, while there is value in the items on
the right, we value the items on the left more.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;A fast summary is that Agile is a framework of developing software projects that focus on delivering working software and collaboration with client.&lt;/p&gt;
&lt;p&gt;Agile assumes we know nothing about what the client needs, so it tries to reduce error making small deliveries that must be validated each time by the client.
Small changes mean small errors. Above all, this tool gives us the opportunity to get some new needs that arise with each new delivery.&lt;/p&gt;
&lt;p&gt;This framework values the team above all. Software is so complex that it is needed many "brains" to develop it. The best solution is reached when all
the members participate.&lt;/p&gt;
&lt;p&gt;Agile doesn't erase Analysis, Software Design and many heuristic practices that should be used by all software engineers. But we can't forget that
we have to deliver working software and not a ton of documents. Our client needs us and needs his/her software.&lt;/p&gt;
&lt;p&gt;To sum up, it gives simple tools and a discipline to avoid making the project software fail.&lt;/p&gt;
&lt;h1&gt;Is this Engineering?&lt;/h1&gt;
&lt;p&gt;On one hand, managing client needs looks like Engineering to me. I'm sure an architect asks what kind of building his/her client wants.&lt;/p&gt;
&lt;p&gt;On the other hand, no, you're right: it is not traditional Engineering. Software is applied logic and is free of all laws other Engineering branches have.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Agile gives the most cautious solution to a problem nobody can solve: how to make evolving software&lt;/strong&gt;.&lt;/p&gt;
&lt;h1&gt;How to start with agile?&lt;/h1&gt;
&lt;p&gt;I just read the book &lt;a href="https://pragprog.com/book/jtrap/the-agile-samurai"&gt;The Agile Samurai by Jonathan Rasmunsson&lt;/a&gt; and is a great introduction to agile mindset.&lt;/p&gt;
&lt;h1&gt;What from now?&lt;/h1&gt;
&lt;p&gt;There is some criticism about the abuse of the term "agile" but I really think it doesn't matter. What matters is this agile manifesto and using what tools you
need to make the client one of your team when developing his/her changing software project.&lt;/p&gt;
&lt;p&gt;You have to use what suits you.&lt;/p&gt;</summary><category term="software engineering"></category><category term="books"></category></entry><entry><title>Literate Programming</title><link href="http://diegojromerolopez.github.io/posts/2015/12/literate-programming/" rel="alternate"></link><updated>2015-12-30T13:05:00+01:00</updated><author><name>Diego J.</name></author><id>tag:diegojromerolopez.github.io,2015-12-30:posts/2015/12/literate-programming/</id><summary type="html">&lt;p&gt;Donald E. Knuth coined the term Literate programming in this &lt;a href="http://www.literateprogramming.com/knuthweb.pdf"&gt;paper&lt;/a&gt; wrote almost 40 years ago.&lt;/p&gt;
&lt;p&gt;Knuth wrote a tool called &lt;strong&gt;WEB&lt;/strong&gt; as a demonstration of what Literate Programming should be. This tool would understand Pascal and TeX code, using Pascal code to create
a binary executable and using TeX code to compile its documentation file. Pascal code would be a bit different because of the use of predefined macros and it would be
interleaved by TeX code describing what actions execute.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;WEB&lt;/strong&gt; was composed by a &lt;strong&gt;weaver&lt;/strong&gt; and a &lt;strong&gt;tangler&lt;/strong&gt;. Its first component (the weaver) was code generator the would pick up the code, expand the macros and compile it, erase the texts of the resulting code and compile it. Its second component was an extractor of documentation written in TeX, where each block of code would be joined in one document that compiled the documentation of the program.&lt;/p&gt;
&lt;p&gt;This amazing idea has been lost thru time. Sure, there are some self-documenting tools like &lt;a href="http://www.stack.nl/~dimitri/doxygen/"&gt;Doxygen&lt;/a&gt; but there is no language that encourages documentation as a part
of the programming task. Donald E. Knuth was ahead of his time (although he says there had been others before him) because of the foundational idea of his work:
&lt;strong&gt;code must be able to be read like a literary piece&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;This is what I encourage to my peers each day: &lt;strong&gt;code must be pleasant&lt;/strong&gt;. Yes, it could be a bit strange
reading “pleasure” and “code” but I would love to see a code with comments that really puts me in context,
give me advice on how to use it, its order of algorithm complexity and inform me of whatever non-standard behavior I should know.&lt;/p&gt;
&lt;p&gt;Nowadays we, software engineers, are not only worried by code that 'just works' but we are worried by making this code secure and easy to maintain and expand.&lt;/p&gt;
&lt;p&gt;In my experience, when dealing with legacy code no documentation is given, only the code and this creates anxiety to the engineer and of course, to the stakeholders. Imagine if your company would have to base its business in a system that nobody knows. Not only its behavior but how it is done. But unfortunately, that is what usually happens. &lt;/p&gt;
&lt;p&gt;I foresee a future language (or maybe an extension to an existing one) not specially worried in efficiency but in easy maintenance. This language could force programmers to write documentation for each sentence/block of code in a language similar to Simple English. Maybe this documentations could be styled in a simply markup language like Markdown.&lt;/p&gt;
&lt;p&gt;Combine this with giving variable, function and class names a semantic meaning (based on common patterns?) and it will be the future bad-programmer-proof language.  &lt;/p&gt;</summary><category term="software engineering"></category><category term="paper"></category><category term="programming"></category><category term="self-documenting code"></category><category term="documentation"></category><category term="quality assurance"></category></entry><entry><title>Out of the tar pit</title><link href="http://diegojromerolopez.github.io/posts/2015/09/out-of-the-tar-pit/" rel="alternate"></link><updated>2015-09-14T22:00:00+02:00</updated><author><name>Diego J.</name></author><id>tag:diegojromerolopez.github.io,2015-09-14:posts/2015/09/out-of-the-tar-pit/</id><summary type="html">&lt;p&gt;"Tar pit" is an idiom used since 1970s based on the similarity between software complexity and tar pits
trapping engineers and animals (resp.).&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.shaffner.us/cs/papers/tarpit.pdf"&gt;Out of the tar pit&lt;/a&gt; is a paper that analyzes the causes of this complexity and classifies it in several categories.
The authors also analyzes the approaches that each type of programming technique uses to sove this complexity problem.&lt;/p&gt;
&lt;p&gt;But the most important contribution the authors do is giving a solution in the form of a new paradigm of computer programming.
They show a declarative language based on Relational Algebra invented by E. Codd that solves the inherent complexity that
plagues the imperative languages code we use everyday.&lt;/p&gt;
&lt;p&gt;This technique is called &lt;em&gt;Functional Relational Programming&lt;/em&gt; by the authors and is based on:
- Functional programming.
- Not making differences between values and relationships (called &lt;em&gt;relvals&lt;/em&gt;).
- Defining inherent constrains for the system.
- Having derived relations that contains the logic of the system.&lt;/p&gt;
&lt;p&gt;I'm amazed by the simplicity and clarity of this approach, like other declarative languages
like SQL, not having to worry about &lt;em&gt;how is it done&lt;/em&gt; and only about &lt;em&gt;what do I want&lt;/em&gt; is perfect
for large software systems.&lt;/p&gt;
&lt;p&gt;Authors Moseley and Marks are worried about performance but in my own experience of developing web software
platforms, performance is the last problem among the developing of the software. Most of
the time problems arise when clients change requirements through the life of the project
and we have to delete and refactor code because these requirement changes are not
consistent with our solution. Of course agile project management helps with that but
the complexity, the bad code and the shortcuts keeps growing until a refactoring is needed.&lt;/p&gt;
&lt;p&gt;I'm sure &lt;em&gt;Functional Relational Programming&lt;/em&gt; systems can free the developer from menial
tasks and help him/her center in the functionality the same way SQL almost completely frees us
when dealing with the storage of our project data.&lt;/p&gt;</summary><category term="software engineering"></category><category term="paper"></category><category term="programming"></category><category term="imperative programming"></category><category term="declarative programming"></category><category term="functional programming"></category></entry><entry><title>Software construction (don't forget what you're paid for)</title><link href="http://diegojromerolopez.github.io/posts/2015/08/software-construction/" rel="alternate"></link><updated>2015-08-25T22:00:00+02:00</updated><author><name>Diego J.</name></author><id>tag:diegojromerolopez.github.io,2015-08-25:posts/2015/08/software-construction/</id><summary type="html">&lt;p&gt;&lt;em&gt;In my voyage from a simply Software Engineer to a master in Software Engineering I'm reading
several books. Thus, I'm posting in this blog whatever thoughts appear in my mind about
Software Developing.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;I'm several chapters in &lt;a href="https://www.microsoft.com/learning/en-us/book.aspx?id=6822"&gt;Code Complete 2nd Ed. of Steve McConnel&lt;/a&gt;
and I'm amazed by the knowledge that it contains. As time goes by I will update this blog
with more information about my findings.&lt;/p&gt;
&lt;p&gt;Specially I've been struck by one basic principle: &lt;strong&gt;Software construction is the only activity that is warrantied to be made in a software development project&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;I love this phrase because in the software development world it seems that there are two
groups in state of permanent disagreement. I've given them the following names:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Crafters&lt;/strong&gt;: people that disregard Software Development as an engineering discipline and
see this activity as a skill similar to cooking, woodcrafting, plumbing, etc.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Engineers&lt;/strong&gt;: they think that software development &lt;strong&gt;is an&lt;/strong&gt; empirical engineering, as
was Civil Engineering until XX century.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I consider the later approach right but I don't want to be lost in the "engineering" and
"management" part of software development&lt;sup id="fnref:1"&gt;&lt;a class="footnote-ref" href="#fn:1" rel="footnote"&gt;1&lt;/a&gt;&lt;/sup&gt; and forget that software developing is not
producing tons of diagrams, documents, issues and many other software project sub-products.&lt;/p&gt;
&lt;p&gt;We should not forget that what we give to our client is basically software. Our client
usually disregard manuals or other kind of parafernalia given to him/her. Our client knows
what he/she wants: a &lt;strong&gt;software that works&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;This is a double-edged sword, I've found many clients with legacy software systems
without any kind of documentation, of course, needing desperately a new feature, or even
worse a, fix in their system.&lt;/p&gt;
&lt;p&gt;Therefore, this latter case is when you, as a software engineer must to read and refactor
&lt;em&gt;foreign code&lt;/em&gt;, not produced by high-standards guided programmers like you (or your team do).
And increase que quality of the code as much as possible&lt;sup id="fnref:2"&gt;&lt;a class="footnote-ref" href="#fn:2" rel="footnote"&gt;2&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;
&lt;p&gt;These kind of scenarios occur every day, so we must not forget that at the end of the
refactoring or fixing code, &lt;strong&gt;only the code tells the truth&lt;/strong&gt;, only the code contains
the functionality&lt;sup id="fnref:3"&gt;&lt;a class="footnote-ref" href="#fn:3" rel="footnote"&gt;3&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;
&lt;p&gt;So, &lt;strong&gt;thou shall not forget what we, software engineers, are bound to produce correct code&lt;/strong&gt;.&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;In Spain, programming is usually considered the least important task in a software project, usually done by self-taught programmers.&amp;#160;&lt;a class="footnote-backref" href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:2"&gt;
&lt;p&gt;Depending of how much our client wants to expend in the refactoring.&amp;#160;&lt;a class="footnote-backref" href="#fnref:2" rev="footnote" title="Jump back to footnote 2 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:3"&gt;
&lt;p&gt;To make a good software it is needed a high knowledge of many disciplines that need to be acquired by studying in university. I will return to this topic in other post.&amp;#160;&lt;a class="footnote-backref" href="#fnref:3" rev="footnote" title="Jump back to footnote 3 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</summary><category term="software engineering"></category><category term="software"></category><category term="thoughts"></category></entry><entry><title>Peopleware (or what they don't told you in college)</title><link href="http://diegojromerolopez.github.io/posts/2015/08/peopleware/" rel="alternate"></link><updated>2015-08-20T00:30:00+02:00</updated><author><name>Diego J.</name></author><id>tag:diegojromerolopez.github.io,2015-08-20:posts/2015/08/peopleware/</id><summary type="html">&lt;p&gt;I've just finished reading &lt;a href="https://en.wikipedia.org/wiki/Peopleware:_Productive_Projects_and_Teams"&gt;Tom De Marco &amp;amp; Timothy Lister's Peopleware&lt;/a&gt; and I feel like
this book should be recommended to all new Software Engineer graduates. Let me put some
light in this matter.&lt;/p&gt;
&lt;p&gt;I've been working for 8 years in a startup and none of my formal education in the University
prepared me for what I was going to experiment. Software Engineering is a social discipline
(we work in teams) but in my Computer Engineering degree&lt;sup id="fnref:1"&gt;&lt;a class="footnote-ref" href="#fn:1" rel="footnote"&gt;1&lt;/a&gt;&lt;/sup&gt; there are no management or organization courses.
So, when you scape the Engineering school you know how to make code but you don't know
really know how to work with another humans and of course know nothing about the perks of
the job. To sum up, &lt;strong&gt;you have no clue about the social component of the job&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;This book is old (1987 in its first edition) but what De Marco &amp;amp; Lister tell us is
timeless. First they introduce the nature of the job of the programmer and what should
be. Later they show the problems of the environment: noise, cubicle floorplans,
the loss of "the flow" etc.
The book ends with more teaching about human resources and productivity.&lt;/p&gt;
&lt;p&gt;It is truly a great book but you should &lt;strong&gt;not&lt;/strong&gt; read from cover to end. The book is organized
in little stories that help you understand the issue that the authors are dealing with.
&lt;strong&gt;It is a nightstand book&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Written in a non-formal way, this book is almost too funny to be considered a "job" book.
Thus, the authors show some kind of comments about other cultures and nations that readers
should not take very seriously to not be offended (Spanish Theory of Management&lt;sup id="fnref:2"&gt;&lt;a class="footnote-ref" href="#fn:2" rel="footnote"&gt;2&lt;/a&gt;&lt;/sup&gt;,
Uganda being "poor" and Australia being always on strike).
This comments seems very unprofessional to me.&lt;/p&gt;
&lt;p&gt;There are some other aspects I didn't like:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Not defining the Parkinsons' Law&lt;sup id="fnref:3"&gt;&lt;a class="footnote-ref" href="#fn:3" rel="footnote"&gt;3&lt;/a&gt;&lt;/sup&gt;, at least in a footnote.&lt;/li&gt;
&lt;li&gt;The use of the term "Corporate Entropy" given that in Physics, Entropy can be viewed as a
measure of chaos and the authors uses it to measure non-originality (sameness) in the employees.&lt;/li&gt;
&lt;li&gt;Not making a difference between programmers and software engineers.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Overall, it's a good book that I recommend to every programmer or software engineer that
is going to start working in his/her first job. &lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;Sadly when I studied there was no Software Engineering degree, only Computer Engineering.&amp;#160;&lt;a class="footnote-backref" href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:2"&gt;
&lt;p&gt;Authors claim that Spaniards thought that the economy could only be improved by the extraction of natural resources while the English thought that resources could be created. They tell that Spaniards where "Indians exploiters" while &lt;strong&gt;omit the barbaric treatment of natives by the English&lt;/strong&gt; (and later by the Americans). Sad sign of the authors being manipulated by the &lt;a href="https://en.wikipedia.org/wiki/Black_Legend"&gt;Black Legend&lt;/a&gt; or simply being manipulative.&amp;#160;&lt;a class="footnote-backref" href="#fnref:2" rev="footnote" title="Jump back to footnote 2 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:3"&gt;
&lt;p&gt;It is not really a law, it was a funny adage created by the British civil servant C. Northcote Parkinson: &lt;em&gt;work expands so as to fill the time available for its completion&lt;/em&gt;.&amp;#160;&lt;a class="footnote-backref" href="#fnref:3" rev="footnote" title="Jump back to footnote 3 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</summary><category term="software engineering"></category><category term="management"></category><category term="soft skills"></category><category term="books"></category></entry><entry><title>Progress Towards an Engineering Discipline of Software by Mary Shaw</title><link href="http://diegojromerolopez.github.io/posts/2015/08/progress-towards-an-engineering-discipline-of-software/" rel="alternate"></link><updated>2015-08-14T20:30:00+02:00</updated><author><name>Diego J.</name></author><id>tag:diegojromerolopez.github.io,2015-08-14:posts/2015/08/progress-towards-an-engineering-discipline-of-software/</id><summary type="html">&lt;p&gt;Several days ago, I watched this videotalk of Mary Shaw that tried to give an answer to the question
is Software Engineering an Engineering discipline yet?&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.youtube.com/watch?v=S03bsjs2YnQ"&gt;&lt;img alt="SATURN 2015 Keynote: Progress Towards an Engineering Discipline of Software by Mary Shaw" src="http://img.youtube.com/vi/S03bsjs2YnQ/0.jpg" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Dr. Shaw makes a parallelism with Civil Engineering that started as a &lt;strong&gt;empirical discipline&lt;/strong&gt;
and, thanks to strong scientific foundations, evolved to what we could call &lt;em&gt;full&lt;/em&gt; engineering.&lt;/p&gt;
&lt;p&gt;Software Engineering is not there yet. It needs more work and professionalization. 
&lt;strong&gt;Many of the so-called Software Engineers have no software engineering knowledge and/or skills&lt;/strong&gt;
and therefore software catastrofes happens. She even gives some examples of software failures
like the &lt;a href="http://www.safetyresearch.net/blog/articles/toyota-unintended-acceleration-and-big-bowl-%E2%80%9Cspaghetti%E2%80%9D-code"&gt;Toyota unintended acceleration affaire&lt;/a&gt;,
and the multiple identity thefts in our connected world.&lt;/p&gt;
&lt;p&gt;At the end of the talk, she makes a good summary of the last years of advancements in
Software Engineering and also drafts what it could be the future of our young discipline.&lt;/p&gt;
&lt;p&gt;One hundred percent I recommend watching this videotalk to every Software Engineer.&lt;/p&gt;</summary><category term="software engineering"></category><category term="engineering"></category><category term="talk"></category><category term="videotalk"></category></entry><entry><title>Concurrency and Third Party Libraries</title><link href="http://diegojromerolopez.github.io/posts/2015/08/concurrency-and-third-party-libraries/" rel="alternate"></link><updated>2015-08-01T19:00:00+02:00</updated><author><name>Diego J.</name></author><id>tag:diegojromerolopez.github.io,2015-08-01:posts/2015/08/concurrency-and-third-party-libraries/</id><summary type="html">&lt;p&gt;Last friday, one of my mates had a strange error in his code: incoherent an irrepetible results arise en each execution.&lt;/p&gt;
&lt;p&gt;His code (Python) was concurrent code and each thread used several libraries (&lt;a href="http://www.crummy.com/software/BeautifulSoup/bs4/doc/"&gt;BeautifulSoup4&lt;/a&gt;&lt;sup id="fnref:1"&gt;&lt;a class="footnote-ref" href="#fn:1" rel="footnote"&gt;1&lt;/a&gt;&lt;/sup&gt; was one of them) which they were &lt;strong&gt;not&lt;/strong&gt; thread-safe. What does it mean? It means we cannot assure that atomicity is achieved in some operations executed by the threads, effectively sharing some data that must not be shared.&lt;/p&gt;
&lt;p&gt;I ended up helping him to set a critical section in these not-thread-safe parts of his code but this situation kept me wondering why a library that parses XML is not thread-safe and what kind of common resources used of the system. I couldn’t spend more time investigating this issue but this kept me wondering if this “feature” is not a case of bad software design.&lt;/p&gt;
&lt;p&gt;Take a look if everything you are using is thread-safe before you start partitioning your execution flow in threads.&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;Technically, BeautifulSoup4 is a wrapper, not a library. Developer can choose several parsers available (html5lib, lxml…) when using it in an application. &lt;a href="https://github.com/html5lib/html5lib-python"&gt;Html5lib&lt;/a&gt; library is what we were using at the time.&amp;#160;&lt;a class="footnote-backref" href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</summary><category term="concurrency"></category><category term="software engineering"></category><category term="programming"></category></entry><entry><title>Managing clients</title><link href="http://diegojromerolopez.github.io/posts/2015/07/managing-clients/" rel="alternate"></link><updated>2015-07-27T23:00:00+02:00</updated><author><name>Diego J.</name></author><id>tag:diegojromerolopez.github.io,2015-07-27:posts/2015/07/managing-clients/</id><summary type="html">&lt;h1&gt;The Players&lt;/h1&gt;
&lt;p&gt;It's not a secret that software engineers prefer a clean and completed specification than metting with clients.&lt;/p&gt;
&lt;p&gt;We tend to think that meetings are a waste of time and many of our colleagues are not very fond of what is called &lt;a href="https://en.wikipedia.org/wiki/Soft_skills"&gt;soft skills&lt;/a&gt;. &lt;/p&gt;
&lt;p&gt;On the other side, we have some clients that have no idea about software and want the changes in their platform now.&lt;/p&gt;
&lt;p&gt;What is all of that? Let me tell you, a recipe for the disaster. &lt;/p&gt;
&lt;h1&gt;The Setting&lt;/h1&gt;
&lt;p&gt;In a startup, we are very close to our clients, so we engineers manage directly the relationship with them.&lt;/p&gt;
&lt;p&gt;Let's add some extra complexity. The project you have assigned to has no documentation and has a high &lt;a href="https://en.wikipedia.org/wiki/Technical_debt"&gt;technical debt&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The client is not cooperating and is impatient...&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;What do you do?&lt;/strong&gt;&lt;/p&gt;
&lt;h1&gt;The Solution&lt;/h1&gt;
&lt;h2&gt;Technical solution&lt;/h2&gt;
&lt;p&gt;The technical debt problem needs to be resolved, how? Analyzing the current system: what does (software requirements) and how does it (software design).&lt;/p&gt;
&lt;h2&gt;Cliente managing&lt;/h2&gt;
&lt;p&gt;The client feels lied by its older outsourcing company, he/she needs a special treatment. How can we give him/her that?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;How can we make our client feel safe with working with us?&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;We have to guide our clients&lt;/h3&gt;
&lt;p&gt;One of the most successful aspects of Agile development is the change of developers-cliente relationship.&lt;/p&gt;
&lt;p&gt;We must be the calendar, reminder and notifier of the client. We define when we are going to end our sprints and deliver the software modules to be validated by our client.&lt;/p&gt;
&lt;h3&gt;Clients are limited&lt;/h3&gt;
&lt;p&gt;Don't suppose any knowledge.&lt;/p&gt;
&lt;p&gt;The client can be wise in his/her field (many times it is not) but doesn't know anything about software.&lt;/p&gt;
&lt;p&gt;We should talk in a simple vocabulary, explaining the concepts, making metaphors and real like comparisons to achieve his/her complete understanding.&lt;/p&gt;
&lt;h3&gt;Clients have needs but ask for changes&lt;/h3&gt;
&lt;p&gt;Clients have background needs because of business or personal requirements but they express them in form of "changes" in the software, even telling us how to do the changes.&lt;/p&gt;
&lt;p&gt;We should know these base needs instead of the particular changes, because most of the time, things can be done easily or better.&lt;/p&gt;
&lt;h3&gt;Don't lose control&lt;/h3&gt;
&lt;p&gt;Clients can be disrespectful, condescending or can be tyrannical. &lt;/p&gt;
&lt;p&gt;We are engineers, we must be assertive, defend our integrity as humans but we must &lt;em&gt;not&lt;/em&gt; attack the client.&lt;/p&gt;
&lt;p&gt;Technology makes people feel vulnerable, specially illiterate people, so they tend to show this feeling as anger or other unpleasant emotions.&lt;/p&gt;
&lt;h1&gt;Conclusion&lt;/h1&gt;
&lt;p&gt;We don't work &lt;em&gt;for&lt;/em&gt; a client, we work &lt;em&gt;with&lt;/em&gt; a client.&lt;/p&gt;
&lt;p&gt;Many times a conversation can avoid developing new features that won't be used or the cancelation of the project.&lt;/p&gt;
&lt;p&gt;Soft skills are important, yes, even for an engineer. You will have mettings with clients, so practice your "human" abilities.&lt;/p&gt;</summary><category term="clients"></category><category term="software engineering"></category><category term="people"></category><category term="project management"></category></entry><entry><title>Real Software Architecture</title><link href="http://diegojromerolopez.github.io/posts/2015/03/real-software-architecture/" rel="alternate"></link><updated>2015-03-03T21:53:00+01:00</updated><author><name>Diego J.</name></author><id>tag:diegojromerolopez.github.io,2015-03-03:posts/2015/03/real-software-architecture/</id><summary type="html">&lt;p&gt;Simon Brown is an independent software consultant from Jersey (UK) and gave this talk
about Software Architecture in GOTO Amsterdam 2014.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.youtube.com/watch?v=GAFZcYlO5S0"&gt;&lt;img alt="Software Architecture vs. Code GOTO 2014 talk" src="http://img.youtube.com/vi/GAFZcYlO5S0/0.jpg" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;This talk delights me in several ways. First, Simon show us several common problems that happens in
many software companies: diagrams of the software are not synchronized with code because.
That is, we design some type of software architecture but we don't follow our own path when
coding.&lt;/p&gt;
&lt;p&gt;He thinks (me too) that software diagram current methodologies are difficult and
not &lt;em&gt;pleasant&lt;/em&gt; (I would say) to use. We continue to theorize about perfect software
designs but when we make the code we simply don't take them in consideration.&lt;/p&gt;
&lt;p&gt;This way, he shows a software architecture model that enfatizes the communication inside
the team and with stakeholders. Thus, the most important thing is that these diagrams
can be the &lt;em&gt;actual plan&lt;/em&gt; of the code of the project and with his guidelines we can have no
discrepancies between software architecture and code organization and structure. &lt;/p&gt;
&lt;p&gt;Simon has published a very &lt;a href="https://leanpub.com/software-architecture-for-developers/"&gt;interesting book&lt;/a&gt; I plan to read.
I'll update this post in the future when I read it.&lt;/p&gt;
&lt;p&gt;Go, watch the video and think about this problem.&lt;/p&gt;</summary><category term="talk"></category><category term="software engineering"></category><category term="videotalk"></category><category term="software architecture"></category></entry><entry><title>Back to basics, the mythical man-month</title><link href="http://diegojromerolopez.github.io/posts/2014/11/back-to-basics-the-mythical-man-month/" rel="alternate"></link><updated>2014-11-04T21:00:00+01:00</updated><author><name>Diego J.</name></author><id>tag:diegojromerolopez.github.io,2014-11-04:posts/2014/11/back-to-basics-the-mythical-man-month/</id><summary type="html">&lt;p&gt;&lt;a href="https://en.wikipedia.org/wiki/Fred_Brooks"&gt;Frederick P. Brooks&lt;/a&gt; is what I'd call a true pioneer.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Frederick P. Brooks" src="/images/FredBrooks.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;Without any existing knowledge and only his own experience in the "tar pit" (as himself call this software development world), he distilled some universal truths of the Software Engineering world. So, the Mythical Man-Month is a summary of his ideas.&lt;/p&gt;
&lt;p&gt;This book is a night stand book, that is, you cannot hope to end it in a few days. You have to read slowly, thinking as a 60s software developer, with their limited tools and machines to fully understand this book.&lt;/p&gt;
&lt;p&gt;Its content can be seen as obvious, but is interesting seeing the thought process that made the bases of what we call now Software Engineering. Things like how to plan a software project, team specialization, the use of high languages over efficiency, a strict and well-done documentation, etc. are described with some detail in the book with real world examples of Brooks or men of his time.&lt;/p&gt;
&lt;p&gt;Of course many readers stop reading after ending chapter 2 where the author explains that software projects are different compared to other projects because you cannot increase development speed introducing more members to the developing team. You'll need to teach them the project internals, increasing the overall time cost of the project. But I think every chapter has its teaching.&lt;/p&gt;
&lt;p&gt;For example, in chapter 3, "The surgical team", Brooks compares a surgical team where every member has a specialized tasks to his idea of software developing team. Nowadays it is very common to see many jobs for "full-stack developers", what in my opinion is completely mistaken. You cannot expect to be fully competent in dozens of disciplines (and technologies).&lt;/p&gt;
&lt;p&gt;Other interesting chapter for me is "The documentary hypothesis" where Brooks defends the idea of having formal documents for each project like objetives, specifications, schedule, etc. In the agile startup world this is simply wasted time, the old idea of "only the code is what is important" has returned very strong this days because of the culture of skyrocketing your career and rockstar programmer. This two ideas are a bit naïve and against the software engineering principles of software quality and maintainability.&lt;/p&gt;
&lt;p&gt;The last thing I want to note about this book is that Brooks even defines the two careers in the software world: programmers and management. Where many people see both of them as oposite careers, Brooks sees them as complementary positions of the organization but encouraging employees to stay in "the technical ladder" by paying them more. Yes, take a look to chapter "Plan the organization for a change".&lt;/p&gt;
&lt;p&gt;To conclude this post, Brooks' book is a window to the past that teach us many principles of Software Engineering with real examples. I recommend its lecture to every undergraduate student of Computer Science or Software Engineering degrees. Many of the problems of nowadays software developing organizations can be seen in this book pages. I encourage every software developer or software engineer to read this book and learn the basic principles of Software Engineering.&lt;/p&gt;</summary><category term="books"></category><category term="software engineering"></category><category term="startup"></category></entry><entry><title>Welcome</title><link href="http://diegojromerolopez.github.io/posts/2014/10/welcome/" rel="alternate"></link><updated>2014-10-01T21:00:00+02:00</updated><author><name>Diego J.</name></author><id>tag:diegojromerolopez.github.io,2014-10-01:posts/2014/10/welcome/</id><summary type="html">&lt;p&gt;For anyone not knowing me, I’m a software engineer working in a startup in south Spain.&lt;/p&gt;
&lt;p&gt;In 2014 I ended my Software Engineering Research Masters Program and not satisfied with what I’ve learned, I’m going to continue my research in this field.&lt;/p&gt;
&lt;p&gt;This blog is going to be my notebook in this amazing trip.&lt;/p&gt;
&lt;p&gt;Please, note that this blogs only reflect my personal opinions and views, it does &lt;em&gt;not&lt;/em&gt; reflect the views of my past, present or future employers.&lt;/p&gt;</summary><category term="welcome"></category><category term="test"></category></entry></feed>